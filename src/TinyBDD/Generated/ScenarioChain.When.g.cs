// <auto-generated/>
namespace TinyBDD;
public sealed partial class ScenarioChain<T>
{
    /// <summary>
    /// Adds a <c>When</c> transformation with an explicit title using sync function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="title">Display title for this step.</param>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(string title, Func<T, TOut> f) =>
        Transform(StepPhase.When, StepWord.Primary, title, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with an explicit title using task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="title">Display title for this step.</param>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(string title, Func<T, Task<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, title, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with an explicit title using a token-aware task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="title">Display title for this step.</param>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(string title, Func<T, CancellationToken, Task<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, title, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with an explicit title using value task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="title">Display title for this step.</param>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(string title, Func<T, ValueTask<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, title, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with an explicit title using a token-aware value task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="title">Display title for this step.</param>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(string title, Func<T, CancellationToken, ValueTask<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, title, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with a default title using sync function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(Func<T, TOut> f) =>
        Transform(StepPhase.When, StepWord.Primary, string.Empty, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with a default title using task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(Func<T, Task<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, string.Empty, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with a default title using a token-aware task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(Func<T, CancellationToken, Task<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, string.Empty, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with a default title using value task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(Func<T, ValueTask<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, string.Empty, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> transformation with a default title using a token-aware value task function.
    /// </summary>
    /// <typeparam name="TOut">The result type of the transformation.</typeparam>
    /// <param name="f">Transformation applied to the carried value.</param>
    /// <returns>A new <see cref="ScenarioChain{TOut}"/> carrying the transformed value.</returns>
    public ScenarioChain<TOut> When<TOut>(Func<T, CancellationToken, ValueTask<TOut>> f) =>
        Transform(StepPhase.When, StepWord.Primary, string.Empty, ToCT(f));

    /// <summary>
    /// Adds a <c>When</c> side-effect with an explicit title. Keeps the current value.
    /// </summary>
    /// <param name="title">Display title for this step.</param>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(string title, Action<T> effect) =>
        Effect(StepPhase.When, StepWord.Primary, title, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with an explicit title. Keeps the current value.
    /// </summary>
    /// <param name="title">Display title for this step.</param>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(string title, Func<T, Task> effect) =>
        Effect(StepPhase.When, StepWord.Primary, title, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with an explicit title. Keeps the current value.
    /// </summary>
    /// <param name="title">Display title for this step.</param>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(string title, Func<T, CancellationToken, Task> effect) =>
        Effect(StepPhase.When, StepWord.Primary, title, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with an explicit title. Keeps the current value.
    /// </summary>
    /// <param name="title">Display title for this step.</param>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(string title, Func<T, ValueTask> effect) =>
        Effect(StepPhase.When, StepWord.Primary, title, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with an explicit title. Keeps the current value.
    /// </summary>
    /// <param name="title">Display title for this step.</param>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(string title, Func<T, CancellationToken, ValueTask> effect) =>
        Effect(StepPhase.When, StepWord.Primary, title, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with a default title. Keeps the current value.
    /// </summary>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(Action<T> effect) =>
        Effect(StepPhase.When, StepWord.Primary, string.Empty, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with a default title. Keeps the current value.
    /// </summary>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(Func<T, Task> effect) =>
        Effect(StepPhase.When, StepWord.Primary, string.Empty, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with a default title. Keeps the current value.
    /// </summary>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(Func<T, CancellationToken, Task> effect) =>
        Effect(StepPhase.When, StepWord.Primary, string.Empty, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with a default title. Keeps the current value.
    /// </summary>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(Func<T, ValueTask> effect) =>
        Effect(StepPhase.When, StepWord.Primary, string.Empty, ToCT(effect));

    /// <summary>
    /// Adds a <c>When</c> side-effect with a default title. Keeps the current value.
    /// </summary>
    /// <param name="effect">Side-effect that receives the carried value.</param>
    /// <returns>The same <see cref="ScenarioChain{T}"/> for further chaining.</returns>
    public ScenarioChain<T> When(Func<T, CancellationToken, ValueTask> effect) =>
        Effect(StepPhase.When, StepWord.Primary, string.Empty, ToCT(effect));

}
